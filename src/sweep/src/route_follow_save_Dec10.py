#!/usr/bin/env python3

###############################################################################
## THIS FILE IS SAVED FOR BACKUP BECAUSE THIS IS A STEADY VERSION OF SIMULATION
## UNLESS NEW VERSION TESTS IN BOTH REAL AND SIMULATION
## AND HAS NO PROBLEMS
## THIS FILE CAN BE DELETED
###############################################################################

import rospy
import yaml
import os
import math
from geometry_msgs.msg import Twist, PoseWithCovarianceStamped
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker, MarkerArray
from std_msgs.msg import String, ColorRGBA
from nav_msgs.msg import Path
from geometry_msgs.msg import PoseStamped
from tf.transformations import euler_from_quaternion
import numpy as np
from geometry_msgs.msg import Point, PoseStamped

"""
THIS IS THE (2) SECOND STEP SCRIPT IN CLEANING FUNCTIONS
THIS IS A UTILITY SCRIPT

FUNCTION:
This script implements a route following system for an autonomous cleaning robot.
It executes the cleaning path generated by the previous planning step while
handling real-time navigation and obstacle avoidance. Key functions include:

1. Path Following:
   - Loads and executes pre-planned cleaning paths
   - Maintains path point status (visited/unvisited/obstacle)
   - Implements motion control for point-to-point navigation
   - Handles path recovery when obstacles are encountered

2. Safety Features:
   - Real-time obstacle detection using laser scanner
   - Dynamic path safety verification
   - Adjustable safety distance thresholds
   - Timeout protection for motion commands

3. Visualization:
   - Real-time status visualization in RViz
   - Color-coded point status display
   - Path connection visualization with arrows
   - Current target path display

4. Status Management:
   - Maintains and updates point visit status
   - Saves progress to allow resume after interruption
   - Provides real-time status feedback
   - Handles AMCL localization accuracy monitoring

The script ensures efficient and safe execution of the cleaning path while 
providing real-time feedback and visualization of the cleaning progress.
"""

# BUG DATE: Dec 10, 2024
# REAL DEMO BUG: CANNOT FOLLOW ROUTE (OR CANNOT START CLEANING FUNCTION)
# NEEDS DEBUG IMMEDIATELY
# SIM DEMO BUG: NO IDEA WHY NO GREEN POINTS SHOWN
# NEEDS DEBUG IMMEDIATELY




# Update: Nov 25, 2024
# Integrated into panel
# Need Update: 
# Need manually switch RViz topic to route_status_visualization

class MapData:
    OBSTACLE = -1    # obstacles points, black
    UNVISITED = 0    # unvisited, red
    VISITED = 1      # visited points, green

class RouteFollower:
    def __init__(self):
        rospy.init_node('route_follower', anonymous=True)
        
        # Settings
        self.POSITION_TOLERANCE = 0.1   # position tolerance (到达目标点的位置误差)
        self.ANGLE_TOLERANCE = 0.1      # angle tolerance (角度误差)
        self.LINEAR_SPEED = 0.2         # linear speed
        self.ANGULAR_SPEED = 0.3        # angular speed
        self.SAFETY_DISTANCE = 0.3      # safety distance
        self.SAMPLING_INTERVAL = 5      # sampling interval, keep same with route_plan
        
        # Store the data
        self.path_points = []
        self.path_connections = []      # store connections
        self.current_pose = None
        self.current_path_index = None
        self.obstacle_points = []
        self.current_path = Path()      # curent path
        
        # Pub and Sub
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        self.status_pub = rospy.Publisher('/route_status', String, queue_size=1)
        self.visualization_pub = rospy.Publisher('/route_status_visualization', MarkerArray, queue_size=1, latch=True)
        self.path_pub = rospy.Publisher('/current_path', Path, queue_size=1, latch=True)
        
        # AMCL and LiDAR
        self.amcl_sub = rospy.Subscriber('/amcl_pose', PoseWithCovarianceStamped, self.amcl_callback)
        self.laser_sub = rospy.Subscriber('/scan', LaserScan, self.laser_callback)
        
        # Load Files
        self.path_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pathfiles")
        if not os.path.exists(self.path_dir):
            os.makedirs(self.path_dir)
        
        self.load_latest_path()
        rospy.loginfo("Route follower initialized")

    def load_latest_path(self):
        """Load the latest path file and reset all point states"""
        try:
            path_files = [f for f in os.listdir(self.path_dir) 
                         if f.startswith('coverage_path_') and f.endswith('.yaml')]
            if not path_files:
                rospy.logwarn("No path files found")
                return False
                
            latest_file = sorted(path_files)[-1]
            path_file = os.path.join(self.path_dir, latest_file)
            rospy.loginfo(f"Loading path from {path_file}")
            
            with open(path_file, 'r') as f:
                data = yaml.safe_load(f)
                self.path_points = data['path_points']
                # reset all points to unvisited
                for point in self.path_points:
                    point['status'] = MapData.UNVISITED
                # rebuild the connections
                self.build_path_connections()
                rospy.loginfo(f"Loaded {len(self.path_points)} path points")
                
            # Delete the old status file if it exists
            status_file = os.path.join(self.path_dir, "path_status.yaml")
            if os.path.exists(status_file):
                os.remove(status_file)
                
            return True
                
        except Exception as e:
            rospy.logerr(f"Error loading path file: {str(e)}")
            return False

    def build_path_connections(self):
        """Build path connection relationship, consistent with route_plan"""
        self.path_connections = []
        visited = set()
        
        if not self.path_points:
            return
            
        current_point = self.path_points[0]
        visited.add(0)
        
        while len(visited) < len(self.path_points):
            best_distance = float('inf')
            best_next_point = None
            best_next_idx = None
            
            # find nearest unvisited point
            for i, point in enumerate(self.path_points):
                if i in visited:
                    continue
                
                # use sampling interval to find the distance
                dx = abs(current_point['grid_x'] - point['grid_x'])
                dy = abs(current_point['grid_y'] - point['grid_y'])
                
                if not ((dx == self.SAMPLING_INTERVAL and dy == 0) or 
                        (dx == 0 and dy == self.SAMPLING_INTERVAL)):
                    continue
                
                distance = math.hypot(
                    current_point['grid_x'] - point['grid_x'],
                    current_point['grid_y'] - point['grid_y']
                )
                
                if distance < best_distance:
                    best_distance = distance
                    best_next_point = point
                    best_next_idx = i
            
            if best_next_point is None:
                # If no adjacent point is found, choose a new starting point from an unvisited point
                unvisited = set(range(len(self.path_points))) - visited
                if unvisited:
                    next_start_idx = min(unvisited)
                    current_point = self.path_points[next_start_idx]
                    visited.add(next_start_idx)
                    continue
                else:
                    break
            
            self.path_connections.append((current_point['id'], best_next_point['id']))
            visited.add(best_next_idx)
            current_point = best_next_point
        
        rospy.loginfo(f"Built {len(self.path_connections)} path connections")

    def get_next_planned_point(self, current_point_id):
        """Get the next point according to the planned path"""
        # Find the next point in a route connection
        for start_id, end_id in self.path_connections:
            if start_id == current_point_id:
                # Find the complete information of the target point
                for point in self.path_points:
                    if point['id'] == end_id and point['status'] == MapData.UNVISITED:
                        # Make sure the next point is accessible
                        if self.check_path_safety(point):
                            return point
        return None

    def find_nearest_accessible_point(self):
        """Find the nearest accessible unvisited point"""
        print("FLAG-find nearest acc...")
        print("=============================")
        print("current pose:")
        print(self.current_pose)

        while not self.current_pose:
            # Dec10 update
            # return None
            print("not found position yet")
            
        min_distance = float('inf')
        nearest_point = None

        print("path points:")
        print(self.path_points)
        
        for point in self.path_points:
            print("point:")
            print(point)
            print("point status:")
            print(point['status'])


            if point['status'] != MapData.UNVISITED:
                continue
                
            distance = math.hypot(
                point['world_x'] - self.current_pose[0],
                point['world_y'] - self.current_pose[1]
            )

            print("distance:")
            print(distance)

            print("now nearest distance:")
            print(nearest_point)
            
            # no more check path safety Dec10 debug
            #if distance < min_distance and self.check_path_safety(point):
            #    min_distance = distance
            #    nearest_point = point

            if distance < min_distance:
                min_distance = distance
                nearest_point = point


        print("nearest point:")
        print(nearest_point)
                
        return nearest_point

    def amcl_callback(self, msg):
        """AMCL callback"""
        position = msg.pose.pose.position
        orientation = msg.pose.pose.orientation
        _, _, yaw = euler_from_quaternion([
            orientation.x, orientation.y, orientation.z, orientation.w])
        self.current_pose = (position.x, position.y, yaw)
        rospy.logdebug(f"AMCL pose updated: x={position.x}, y={position.y}, yaw={yaw}")


    def laser_callback(self, scan_msg):
        """LiDAR callback"""
        if not self.current_pose:
            return

        self.obstacle_points = []
        angle = scan_msg.angle_min
        
        for r in scan_msg.ranges:
            if scan_msg.range_min <= r <= scan_msg.range_max:
                # Convert to map coordinate system
                x = self.current_pose[0] + r * math.cos(angle + self.current_pose[2])
                y = self.current_pose[1] + r * math.sin(angle + self.current_pose[2])
                self.obstacle_points.append((x, y))
            angle += scan_msg.angle_increment

    def check_path_safety(self, target_point):
        """Check if the path to the destination is safe"""
        if not self.current_pose or not self.obstacle_points:
            return True
            
        path_start = np.array([self.current_pose[0], self.current_pose[1]])
        path_end = np.array([target_point['world_x'], target_point['world_y']])
        path_vector = path_end - path_start
        path_length = np.linalg.norm(path_vector)
        
        if path_length == 0:
            return True
            
        for obs_point in self.obstacle_points:
            obs_vector = np.array(obs_point) - path_start
            # Calculate projection
            projection = np.dot(obs_vector, path_vector) / path_length
            
            if 0 <= projection <= path_length:
                # Calculate vertical distance
                distance = abs(np.cross(path_vector, obs_vector)) / path_length
                if distance < self.SAFETY_DISTANCE:
                    return False
        
        return True

    def publish_point_status(self):
        """Publish the status of all points for visualization"""
        point_markers = MarkerArray()
        
        for i, point in enumerate(self.path_points):
            marker = Marker()
            marker.header.frame_id = "map"
            marker.header.stamp = rospy.Time.now()
            marker.ns = "path_points"
            marker.id = i
            marker.type = Marker.SPHERE
            marker.action = Marker.ADD
            
            marker.pose.position.x = point['world_x']
            marker.pose.position.y = point['world_y']
            marker.pose.position.z = 0.0
            marker.pose.orientation.w = 1.0
            
            marker.scale.x = marker.scale.y = marker.scale.z = 0.1
            
            if point['status'] == MapData.VISITED:
                marker.color = ColorRGBA(0.0, 1.0, 0.0, 0.8)  # green
            elif point['status'] == MapData.OBSTACLE:
                marker.color = ColorRGBA(0.0, 0.0, 0.0, 0.8)  # black
            else:
                marker.color = ColorRGBA(1.0, 0.0, 0.0, 0.8)  # red
                
            point_markers.markers.append(marker)

        # Add visualization of path connections
        for i, (start_id, end_id) in enumerate(self.path_connections):
            start_point = next(p for p in self.path_points if p['id'] == start_id)
            end_point = next(p for p in self.path_points if p['id'] == end_id)
            
            marker = Marker()
            marker.header.frame_id = "map"
            marker.header.stamp = rospy.Time.now()
            marker.ns = "path_connections"
            marker.id = i
            marker.type = Marker.ARROW
            marker.action = Marker.ADD
            
            # Set the arrow start and end points
            marker.points = [
                Point(x=start_point['world_x'], y=start_point['world_y'], z=0),
                Point(x=end_point['world_x'], y=end_point['world_y'], z=0)
            ]
            
            # Set the arrow size
            marker.scale.x = 0.02  # Arrow width
            marker.scale.y = 0.04  # Arrow head width
            marker.scale.z = 0.01  # Arrow height
            
            # Arrow color
            marker.color = ColorRGBA(0.3, 0.3, 1.0, 0.8) # blue
            
            point_markers.markers.append(marker)
        
        self.visualization_pub.publish(point_markers)

    def publish_current_path(self, target_point):
        """Publish the current path for visualization"""
        if not self.current_pose:
            return
            
        path_msg = Path()
        path_msg.header.frame_id = "map"
        path_msg.header.stamp = rospy.Time.now()

        # Add starting point (current location)
        start_pose = PoseStamped()
        start_pose.header = path_msg.header
        start_pose.pose.position.x = self.current_pose[0]
        start_pose.pose.position.y = self.current_pose[1]
        start_pose.pose.orientation.w = 1.0
        path_msg.poses.append(start_pose)

        # Add Target Point
        target_pose = PoseStamped()
        target_pose.header = path_msg.header
        target_pose.pose.position.x = target_point['world_x']
        target_pose.pose.position.y = target_point['world_y']
        target_pose.pose.orientation.w = 1.0
        path_msg.poses.append(target_pose)

        self.path_pub.publish(path_msg)

    def move_to_point(self, target_point):
        """Move to target point"""
        if not self.current_pose:
            return False
            
        rate = rospy.Rate(10)  # 10Hz
        cmd_vel = Twist()
        
        start_time = rospy.Time.now()
        timeout = rospy.Duration(30.0)  # 30 seconds timeout
        
        while not rospy.is_shutdown():
            if not self.current_pose:
                continue
                
            # Checking for timeout
            if (rospy.Time.now() - start_time) > timeout:
                rospy.logwarn("Move to point timeout")
                self.stop_robot()
                return False
                
            # Check path safety
            if not self.check_path_safety(target_point):
                rospy.logwarn("Path blocked by obstacle")
                self.stop_robot()
                return False
                
            # Calculating distances and angles
            dx = target_point['world_x'] - self.current_pose[0]
            dy = target_point['world_y'] - self.current_pose[1]
            distance = math.hypot(dx, dy)
            target_angle = math.atan2(dy, dx)
            
            # If you reach the destination
            if distance < self.POSITION_TOLERANCE:
                self.stop_robot()
                return True
                
            # Calculate the angle difference
            angle_diff = target_angle - self.current_pose[2]
            angle_diff = math.atan2(math.sin(angle_diff), math.cos(angle_diff))
            
            # Determine the movement mode based on the angle difference
            if abs(angle_diff) > self.ANGLE_TOLERANCE:
                # Rotate to the correct direction
                cmd_vel.linear.x = 0.0
                cmd_vel.angular.z = self.ANGULAR_SPEED if angle_diff > 0 else -self.ANGULAR_SPEED
            else:
                # Keep moving forward while maintaining direction
                cmd_vel.linear.x = min(self.LINEAR_SPEED, distance)
                cmd_vel.angular.z = 0.5 * angle_diff  # Maintain direction using proportional control
                
            self.cmd_vel_pub.publish(cmd_vel)
            rate.sleep()
            
        self.stop_robot()
        return False

    def stop_robot(self):
        """Stop Robot"""
        cmd_vel = Twist()
        self.cmd_vel_pub.publish(cmd_vel)

    def check_localization_accuracy(self):
        """Check AMCL positioning accuracy"""
        if not self.current_pose:
            return False, "No pose data"
        return True, "Localization accuracy sufficient"

    def update_point_status(self, point_id, new_status=MapData.VISITED):
        """Update point status"""
        for point in self.path_points:
            if point['id'] == point_id:
                point['status'] = new_status
                self.publish_point_status()
                self.save_points_status()
                return True
        return False

    def save_points_status(self):
        """Save waypoint status"""
        status_file = os.path.join(self.path_dir, "path_status.yaml")
        status_data = {
            'timestamp': rospy.get_time(),
            'points_status': [
                {
                    'id': point['id'],
                    'status': point['status']
                }
                for point in self.path_points
            ]
        }
        
        try:
            with open(status_file, 'w') as f:
                yaml.dump(status_data, f)
        except Exception as e:
            rospy.logwarn(f"Error saving status file: {str(e)}")

    def follow_route(self):
        """Main control loop"""
        rospy.loginfo("Starting route following...")
        rate = rospy.Rate(10)  # 10Hz
        
        while not rospy.is_shutdown():
            # Check positioning
            accuracy_ok, msg = self.check_localization_accuracy()
            if not accuracy_ok:
                print("FLAG1")
                rospy.logwarn(msg)
                rate.sleep()
                continue
                
            # If there is no current target point, find a new one
            if self.current_path_index is None:
                print("FLAG2")
                next_point = self.find_nearest_accessible_point()
                if not next_point:
                    rospy.loginfo("No more accessible points. Mission complete!")
                    break
                self.current_path_index = next_point['id']
            
            # Get the current target point
            current_target = None
            for point in self.path_points:
                if point['id'] == self.current_path_index:
                    current_target = point
                    break
            
            if not current_target:
                rospy.logwarn("Current target point not found")
                self.current_path_index = None
                continue
            
            # Check path safety
            if not self.check_path_safety(current_target):
                rospy.logwarn("Path to target blocked")
                self.update_point_status(current_target['id'], MapData.OBSTACLE)
                self.current_path_index = None
                continue
            
            # Publish current path
            self.publish_current_path(current_target)
            
            # Move to target point
            if self.move_to_point(current_target):
                # Update point status
                self.update_point_status(current_target['id'])
                
                # Prioritize obtaining the next point in the planned path
                next_point = self.get_next_planned_point(current_target['id'])
                
                if not next_point:
                    # If there is no next point in the planned path, find the nearest reachable point
                    next_point = self.find_nearest_accessible_point()
                
                if next_point:
                    self.current_path_index = next_point['id']
                else:
                    rospy.loginfo("No more points to visit")
                    break
            else:
                rospy.logwarn("Failed to reach target point")
                self.update_point_status(current_target['id'], MapData.OBSTACLE)
                self.current_path_index = None
            
            rate.sleep()
        
        self.stop_robot()
        rospy.loginfo("Route following completed")

    def run(self):
        """Run Path Follower"""
        # Waiting for initial positioning
        rospy.sleep(2)  # Give AMCL some time for initial positioning
        
        if not self.path_points:
            rospy.logerr("No path points loaded. Cannot start route following.")
            return
            
        try:
            # start route_follow
            self.follow_route()
        except KeyboardInterrupt:
            self.stop_robot()
            rospy.loginfo("Route following interrupted by user")
        except Exception as e:
            self.stop_robot()
            rospy.logerr(f"Route following error: {str(e)}")
            raise 

if __name__ == "__main__":
    try:
        follower = RouteFollower()
        follower.run()
    except rospy.ROSInterruptException:
        pass